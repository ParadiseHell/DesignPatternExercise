package com.chengtao.entity;

import java.io.Serializable;

import com.chengtao.impl.BaseImpl;

public class Complex implements BaseImpl, Serializable {
	/**
	 * 
	 */
	private static final long serialVersionUID = -2281397264960916488L;
	/**
	 * 实部
	 */
	private float real;
	/**
	 * 虚部
	 */
	private float imaginary;

	/**
	 * 
	 * @param real
	 *            实部
	 * @param imaginary
	 *            虚部
	 */
	public Complex(float real, float imaginary) {
		super();
		this.real = real;
		this.imaginary = imaginary;
	}

	public float getReal() {
		return real;
	}

	public void setReal(float real) {
		this.real = real;
	}

	public float getImaginary() {
		return imaginary;
	}

	public void setImaginary(float imaginary) {
		this.imaginary = imaginary;
	}

	/**
	 * 判断是否为0
	 * 
	 * @return
	 */
	boolean isZero() {
		return real == 0 && imaginary == 0;
	}

	/**
	 * 复数加法
	 * 
	 * @param c
	 *            一个复数
	 * @return
	 */
	public Complex add(Complex c) {
		return calculate(c, CalculateType.ADD);
	}

	/**
	 * 复数减法
	 * 
	 * @param c
	 *            一个复数
	 * @return
	 */
	public Complex subtract(Complex c) {
		return calculate(c, CalculateType.SUB);
	}

	/**
	 * 复数乘法
	 * 
	 * @param c
	 *            一个复数
	 * @return
	 */
	public Complex multiply(Complex c) {
		return calculate(c, CalculateType.MULTI);
	}


	/**
	 * 获取复数的相反数
	 * 
	 * @return
	 */
	public Complex negative() {
		return calculate(this, CalculateType.NEG);
	}
	
	/**
	 * 
	 * @param strComplex
	 * @return
	 */
	public static Complex parseComplex(String strComplex){
		Complex complex = null;
		String complexStrs = strComplex.replace(" ", "");
		if (complexStrs.indexOf('i') != -1) {// 有虚数部分
			if (complexStrs.indexOf('+') != -1) {
				try {
					complex = new Complex(Float.parseFloat(complexStrs.substring(0, complexStrs.indexOf('+'))),
							Float.parseFloat(
									complexStrs.substring(complexStrs.indexOf('+') + 1, complexStrs.length())));
				} catch (Exception e) {
					System.out.println("复数字符串有问题");
				} finally {
					complex = null;
				}
			} else if (complexStrs.indexOf('-') != -1) {
				try {
					complex = new Complex(Float.parseFloat(complexStrs.substring(0, complexStrs.indexOf('-'))),

							(-1 * Float.parseFloat(complexStrs.substring(complexStrs.indexOf('-') + 1,
									complexStrs.length()))));
				} catch (Exception e) {
					System.out.println("复数字符串有问题");
				} finally {
					complex = null;
				}
			}
		} else {// 无虚数部分
			try {
				complex = new Complex(Float.parseFloat(complexStrs), 0);
			} catch (Exception e) {
				System.out.println("复数字符串有问题");
			} finally {
				complex = null;
			}
		}
		return complex;
	}
	
	/**
	 * 拷贝方法
	 */
	@Override
	public Complex clone() {
		return calculate(this, CalculateType.COPY);
	}

	@SuppressWarnings("unchecked")
	@Override
	public <T> T calculate(Object obj, CalculateType type) throws NullPointerException {
		Complex complex = null;
		if (obj instanceof Complex) {
			Complex c = (Complex) obj;
			switch (type) {
			case ADD:
				complex = new Complex(this.real + c.real, this.imaginary + c.imaginary);
				break;
			case SUB:
				complex = new Complex(this.real - c.real, this.imaginary - c.imaginary);
				break;
			case MULTI:
				complex = new Complex(((this.real * c.real) - (this.imaginary * c.imaginary)),
						((this.imaginary * c.real) + (this.real * c.imaginary)));
				break;
			case NEG:
				complex = new Complex((-1 * this.real), (-1 * this.imaginary));
				break;
			case COPY:
				complex = new Complex(this.real, this.imaginary);
				break;
			default:
				break;
			}
		}
		return (T) complex;
	}
	
	@Override
	public String toString() {
		String complexStr = "";
		complexStr += this.getReal();
		if (this.imaginary >= 0) {
			complexStr += " + " + this.getImaginary() + "i";
		} else if (this.imaginary < 0) {
			complexStr += " - " + (-1 * this.getImaginary()) + "i";
		}
		return complexStr;
	}

	/**
	 * 显示复数
	 */
	public void display() {
		System.out.println(this.toString());
	}
}
